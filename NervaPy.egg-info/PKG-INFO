Metadata-Version: 2.1
Name: NervaPy
Version: 0.2.0
Summary: Experimental Python framework for exploring advanced program synthesis and transformation techniques
Home-page: https://github.com/Maratyszcza/PeachPy/
Author: Marat Dukhan
Author-email: maratek@gmail.com
Keywords: assembly,codegen,x86-64
Classifier: Development Status :: 3 - Alpha
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: BSD License
Classifier: Operating System :: OS Independent
Classifier: Operating System :: Microsoft :: Windows
Classifier: Operating System :: POSIX :: Linux
Classifier: Operating System :: POSIX :: FreeBSD
Classifier: Operating System :: MacOS :: MacOS X
Classifier: Programming Language :: Assembly
Classifier: Programming Language :: Python
Classifier: Programming Language :: Python :: 2
Classifier: Programming Language :: Python :: 2.7
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.2
Classifier: Programming Language :: Python :: 3.3
Classifier: Programming Language :: Python :: 3.4
Classifier: Programming Language :: Python :: 3.5
Classifier: Programming Language :: Python :: Implementation :: CPython
Classifier: Programming Language :: Python :: Implementation :: PyPy
Classifier: Natural Language :: English
Classifier: Topic :: Scientific/Engineering
Classifier: Topic :: Software Development
Classifier: Topic :: Software Development :: Assemblers
Classifier: Topic :: Software Development :: Code Generators
Classifier: Topic :: Software Development :: Compilers
Classifier: Topic :: Software Development :: Libraries
License-File: LICENSE.rst

.. image:: https://github.com/kriskwiatkowski/NervaPy/blob/master/logo/nervapy.png
  :alt: NervaPy logo
  :align: center

===========================================================================
NervaPy
===========================================================================

NervaPy is a Python framework for writing high-performance assembly kernels.

NervaPy aims to simplify writing optimized assembly kernels while preserving all optimization opportunities of traditional assembly. Some NervaPy features:

- Universal assembly syntax for Windows, Unix, and Golang assembly.

  * NervaPy can directly generate ELF, MS COFF and Mach-O object files and assembly listings for Golang toolchain

- Automatic adaption of function to different calling conventions and ABIs.
  
  * Functions for different platforms can be generated from the same assembly source
  * Supports Microsoft x64 ABI, System V x86-64 ABI (Linux, OS X, and FreeBSD), Linux x32 ABI, Native Client x86-64 SFI ABI, Golang AMD64 ABI, Golang AMD64p32 ABI
      
- Automatic register allocation.
  
  * NervaPy is flexible and lets mix auto-allocated and hardcoded registers in the same code.

- Automation of routine tasks in assembly programming:

  * Function prolog and epilog and generated by NervaPy
  * De-duplication of data constants (e.g. `Constant.float32x4(1.0)`)
  * Analysis of ISA extensions used in a function

- Supports x86-64 instructions up to AVX-512 and SHA
  
  * Including 3dnow!+, XOP, FMA3, FMA4, TBM and BMI2.
  * Excluding x87 FPU and most system instructions.

- Auto-generation of metadata files

  * Makefile with module dependencies (`-MMD` and `-MF` options)
  * C header for the generated functions
  * Function metadata in JSON format

- Python-based metaprogramming and code-generation.
- Multiplexing of multiple instruction streams (helpful for software pipelining).
- Compatible with Python 2 and Python 3, CPython and PyPy.

Installation
------------

NervaPy is actively developed, and thus there are presently no stable releases of 0.2 branch. We recommend that you use the `master` version:

.. code-block:: bash

  pip install --upgrade git+https://github.com/kriskwiatkowski/NervaPy

Installation for development
****************************

If you plan to modify NervaPy, we recommend the following installation procedure:

.. code-block:: bash

  git clone https://github.com/kriskwiatkowski/NervaPy.git
  cd NervaPy
  python setup.py develop


Using NervaPy as a command-line tool
------------------------------------

.. code-block:: python
  
  # These two lines are not needed for NervaPy, but will help you get autocompletion in good code editors
  from nervapy import *
  from nervapy.x86_64 import *

  # Lets write a function float DotProduct(const float* x, const float* y)
  
  # If you want maximum cross-platform compatibility, arguments must have names
  x = Argument(ptr(const_float_), name="x")
  # If name is not specified, it is auto-detected
  y = Argument(ptr(const_float_))

  # Everything inside the `with` statement is function body
  with Function("DotProduct", (x, y), float_,
    # Enable instructions up to SSE4.2
    # NervaPy will report error if you accidentally use a newer instruction
    target=uarch.default + isa.sse4_2):
  
    # Request two 64-bit general-purpose registers. No need to specify exact names.
    reg_x, reg_y = GeneralPurposeRegister64(), GeneralPurposeRegister64()

    # This is a cross-platform way to load arguments. NervaPy will map it to something proper later.
    LOAD.ARGUMENT(reg_x, x)
    LOAD.ARGUMENT(reg_y, y)

    # Also request a virtual 128-bit SIMD register...
    xmm_x = XMMRegister()
    # ...and fill it with data
    MOVAPS(xmm_x, [reg_x])
    # It is fine to mix virtual and physical (xmm0-xmm15) registers in the same code
    MOVAPS(xmm2, [reg_y])

    # Execute dot product instruction, put result into xmm_x
    DPPS(xmm_x, xmm2, 0xF1)

    # This is a cross-platform way to return results. NervaPy will take care of ABI specifics.
    RETURN(xmm_x)

Now you can compile this code into a binary object file that you can link into a program...

.. code-block:: bash

  # Use MS-COFF format with Microsoft ABI for Windows
  python -m nervapy.x86_64 -mabi=ms -mimage-format=ms-coff -o example.obj example.py
  # Use Mach-O format with SysV ABI for OS X
  python -m nervapy.x86_64 -mabi=sysv -mimage-format=mach-o -o example.o example.py
  # Use ELF format with SysV ABI for Linux x86-64
  python -m nervapy.x86_64 -mabi=sysv -mimage-format=elf -o example.o example.py
  # Use ELF format with x32 ABI for Linux x32 (x86-64 with 32-bit pointer)
  python -m nervapy.x86_64 -mabi=x32 -mimage-format=elf -o example.o example.py
  # Use ELF format with Native Client x86-64 ABI for Chromium x86-64
  python -m nervapy.x86_64 -mabi=nacl -mimage-format=elf -o example.o example.py

What else? You can convert the program to Plan 9 assembly for use with Go programming language:

.. code-block:: bash

  # Use Go ABI (asm version) with -S flag to generate assembly for Go x86-64 targets
  python -m nervapy.x86_64 -mabi=goasm -S -o example_amd64.s example.py
  # Use Go-p32 ABI (asm version) with -S flag to generate assembly for Go x86-64 targets with 32-bit pointers
  python -m nervapy.x86_64 -mabi=goasm-p32 -S -o example_amd64p32.s example.py

If Plan 9 assembly is too restrictive for your use-case, generate ``.syso`` objects `which can be linked into Go programs <https://github.com/golang/go/wiki/GcToolchainTricks#use-syso-file-to-embed-arbitrary-self-contained-c-code>`_:

.. code-block:: bash

  # Use Go ABI (syso version) to generate .syso objects for Go x86-64 targets
  # Image format can be any (ELF/Mach-O/MS-COFF)
  python -m nervapy.x86_64 -mabi=gosyso -mimage-format=elf -o example_amd64.syso example.py
  # Use Go-p32 ABI (syso version) to generate .syso objects for Go x86-64 targets with 32-bit pointers
  # Image format can be any (ELF/Mach-O/MS-COFF)
  python -m nervapy.x86_64 -mabi=gosyso-p32 -mimage-format=elf -o example_amd64p32.syso example.py

See `examples <https://github.com/kriskwiatkowski/NervaPy/tree/master/examples>`_ for real-world scenarios of using NervaPy with ``make``, ``nmake`` and ``go generate`` tools.

Using NervaPy as a Python module
--------------------------------

When command-line tool does not provide sufficient flexibility, Python scripts can import NervaPy objects from ``nervapy`` and ``nervapy.x86_64`` modules and do arbitrary manipulations on output images, program structure, instructions, and bytecodes.

NervaPy as Inline Assembler for Python
**************************************

NervaPy links assembly and Python: it represents assembly instructions and syntax as Python classes, functions, and objects.
But it also works the other way around: NervaPy can represent your assembly functions as callable Python functions!

.. code-block:: python

  from nervapy import *
  from nervapy.x86_64 import *

  x = Argument(int32_t)
  y = Argument(int32_t)

  with Function("Add", (x, y), int32_t) as asm_function:
      reg_x = GeneralPurposeRegister32()
      reg_y = GeneralPurposeRegister32()

      LOAD.ARGUMENT(reg_x, x)
      LOAD.ARGUMENT(reg_y, y)

      ADD(reg_x, reg_y)

      RETURN(reg_x)

  python_function = asm_function.finalize(abi.detect()).encode().load()

  print(python_function(2, 2)) # -> prints "4"

NervaPy as Instruction Encoder
******************************

NervaPy can be used to explore instruction length, opcodes, and alternative encodings:

.. code-block:: python

  from nervapy.x86_64 import *

  ADD(eax, 5).encode() # -> bytearray(b'\x83\xc0\x05')

  MOVAPS(xmm0, xmm1).encode_options() # -> [bytearray(b'\x0f(\xc1'), bytearray(b'\x0f)\xc8')]
  
  VPSLLVD(ymm0, ymm1, [rsi + 8]).encode_length_options() # -> {6: bytearray(b'\xc4\xe2uGF\x08'),
                                                         #     7: bytearray(b'\xc4\xe2uGD&\x08'),
                                                         #     9: bytearray(b'\xc4\xe2uG\x86\x08\x00\x00\x00')}

